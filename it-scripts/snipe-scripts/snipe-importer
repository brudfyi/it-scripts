#!/usr/local/bin/python3
#
# User /bin/python3 for typical systems
#
# Based on jamf2snipe - Inventory Import - https://snipeitapp.com
#
# LICENSE:
#   GLPv3
#
# CONFIGURATION:
#   These settings are commonly found in the settings.conf file.
#
#   This setting sets the Snipe Asset status when creating a new asset. By default it's set to 4 (Pending).
#   defaultStatus = 4
#
#   You can associate snipe hardware keys in the [api-mapping] section, to to a JAMF keys so it associates
#   the jamf values into snipe. The default example associates information that exists by default in both
#   Snipe and JAMF.  The Key value is the exact name of the snipe key name.
#   Value1 is the "Subset" (JAMF's wording not mine) name, and the Value2 is the JAMF key name.
#   Note that MAC Address are a custom value in SNIPE by default and you can use it as an example.
#
#   [api-mapping]
#       name = general name
#       _snipeit_mac_address_1 = general mac_address
#       _snipeit_custom_name_1234567890 = subset jamf_key
#
#   A list of valid subsets are:
validsubset = [
        "general",
        "location",
        "purchasing",
        "peripherals",
        "hardware",
        "certificates",
        "software",
        "extension_attributes",
        "groups_accounts",
        "iphones",
        "configuration_profiles"
]

# Import all the things
import json
import requests
import time
import configparser
import argparse
import logging
import os
import re
import math
import string

class EnvironmentInterpolation(configparser.BasicInterpolation):
    def before_get(self, parser, section, option, value, defaults):
        value = super().before_get(parser, section, option, value, defaults)
        return os.path.expandvars(value)

# Set us up for using runtime arguments by defining them.
runtimeargs = argparse.ArgumentParser()
runtimeargs.add_argument("-v", "--verbose", help="Sets the logging level to INFO and gives you a better idea of what the script is doing.", action="store_true")
runtimeargs.add_argument("--dryrun", help="This checks your config and tries to contact both the JAMFPro and Snipe-it instances, but exits before updating or syncing any assets.", action="store_true")
runtimeargs.add_argument("-d", "--debug", help="Sets logging to include additional DEBUG messages.", action="store_true")
runtimeargs.add_argument("--update_jamf", help="Updates JAMF with the asset tags stored in Snipe.", action="store_true")
runtimeargs.add_argument('--do_not_verify_ssl', help="Skips SSL verification for all requests. Helpful when you use self-signed certificate.", action="store_false")
runtimeargs.add_argument("-r", "--ratelimited", help="Puts a half second delay between Snipe IT API calls to adhere to the standard 120/minute rate limit", action="store_true")
runtimeargs.add_argument("-f", "--force", help="Updates the Snipe asset with information from Jamf every time, despite what the timestamps indicate.", action="store_true")
user_opts = runtimeargs.add_mutually_exclusive_group()
user_opts.add_argument("-u", "--users", help="Checks out the item to the current user in Jamf if it's not already deployed", action="store_true")
user_opts.add_argument("-ui", "--users_inverse", help="Checks out the item to the current user in Jamf if it's already deployed", action="store_true")
user_opts.add_argument("-uf", "--users_force", help="Checks out the item to the user specified in Jamf no matter what", action="store_true")
user_opts.add_argument("-uns", "--users_no_search", help="Doesn't search for any users if the specified fields in Jamf and Snipe don't match. (case insensitive)", action="store_true")
type_opts = runtimeargs.add_mutually_exclusive_group()
type_opts.add_argument("-m", "--mobiles", help="Runs against the JAMF and Google mobiles endpoints only.", action="store_true")
type_opts.add_argument("-c", "--computers", help="Runs against the JAMF computers endpoint only.", action="store_true")
user_args = runtimeargs.parse_args()

# Notify users they're going to get a wall of text in verbose mode.
if user_args.verbose:
    logging.basicConfig(level=logging.INFO)
elif user_args.debug:
    logging.basicConfig(level=logging.DEBUG)
else:
    logging.basicConfig(level=logging.WARNING)

# Notify users if we're doing a dry run.
if user_args.dryrun:
    print("Dryrun: Starting snipe-importer in dry run mode, nothing will be updated.")

# Find a valid settings.conf file.
logging.info("Searching for a valid settings.conf file.")
config = configparser.ConfigParser(interpolation=EnvironmentInterpolation())
logging.debug("Checking for a settings.conf in /opt/jamf2snipe ...")
config.read("/opt/jamf2snipe/settings.conf")
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in: /opt Checking for a settings.conf in /etc/jamf2snipe ...")
    config.read('/etc/jamf2snipe/settings.conf')
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in /etc Checking for a settings.conf in current directory ...")
    config.read("settings.conf")
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in current folder.")
    logging.error("No valid settings.conf was found. We'll need to quit while you figure out where the settings are at. You can check the README for valid locations.")
    raise SystemExit("Error: No valid settings.conf - Exiting.")

logging.info("Great, we found a settings file. Let's get started by parsing all fo the settings.")

# Set some Variables from the settings.conf:
# This is the address, cname, or FQDN for your JamfPro instance.
jamfpro_base = config['jamf']['url']
logging.info("The configured JAMFPro base url is: {}".format(jamfpro_base))
jamf_api_user = config['jamf']['username']
logging.info("The configured JAMFPro username we'll be connecting with is: {}".format(jamf_api_user))
jamf_api_password = config['jamf']['password']
logging.debug("The configured password to access the API is: {}".format(jamf_api_password))

google_base = config['google']['url']
google_api_key = config['google']['apiKey']

okta_base = config['okta']['url']
okta_api_key = config['okta']['apiKey']
okta_filter = config['okta']['filter'].lower()



# This is the address, cname, or FQDN for your snipe-it instance.
snipe_base = config['snipe-it']['url']
logging.info("The configured Snipe-IT base url is: {}".format(snipe_base))
snipe_api_key = config['snipe-it']['apiKey']
logging.debug("The API key you provided for Snipe is: {}".format(snipe_api_key))
defaultStatus = config['snipe-it']['defaultStatus']
logging.info("The default status we'll be setting updated computer to is: {} (I sure hope this is a number or something is probably wrong)".format(defaultStatus))
emailDomain = config['snipe-it']['email_domain']

# List of licensed packages
if 'licensed-software' in config and 'licensed-software' in config['licensed-software']:
    print(config['licensed-software']['licensed-software'])
    licensed_packages = []
    pkg_strings = config['licensed-software']['licensed-software'].split('|')
    for pkg_string in pkg_strings:
        pkg = {}
        packages = []
        pkg_parts = pkg_string.split(',')
        i = 0
        while i < len(pkg_parts):
            if i == 0:
                pkg['vendor'] = pkg_parts[0]
            else:
                packages.append(pkg_parts[i])
            i += 1
        pkg['packages'] = packages
        licensed_packages.append(pkg)

# Headers for the API call.
logging.info("Creating the headers we'll need for API calls")
jamfheaders = {'Accept': 'application/json'}
snipeheaders = {'Authorization': 'Bearer {}'.format(snipe_api_key), 'Accept': 'application/json','Content-Type':'application/json'}
oktaheaders = {'Authorization': 'SSWS {}'.format(okta_api_key), 'Accept': 'application/json', 'Content-Type':'application/json'}
googleheaders = {}
logging.debug('Request headers for JamfPro will be: {}\nRequest headers for Snipe will be: {}'.format(jamfheaders, snipeheaders))

# Check the config file for correct headers

# Do some tests to see if the user has updated their settings.conf file
SETTINGS_CORRECT = True
if 'api-mapping' in config:
    logging.error("Looks like you're using the old method for api-mapping. Please use computers-api-mapping and mobile_devices-api-mapping.")
    SETTINGS_CORRECT = False
if not 'user-mapping' in config and (user_args.users or user_args.users_force or user_args.users_inverse):
    logging.error("""You've chosen to check out assets to users in some capacity using a cmdline switch, but not specified how you want to
    search Snipe IT for the users from Jamf. Make sure you have a 'user-mapping' section in your settings.conf file.""")
    SETTINGS_CORRECT = False

if not SETTINGS_CORRECT:
    raise SystemExit

# Check the config file for valid jamf subsets. This is based off the JAMF API and if it's not right we can't map fields over to SNIPE properly.
logging.debug("Checking the settings.conf file for valid JAMF subsets of the JAMF API so mapping can occur properly.")
for key in config['computers-api-mapping']:
    jamfsplit = config['computers-api-mapping'][key].split()
    if jamfsplit[0] in validsubset:
        logging.info('Found subset {}: Acceptable'.format(jamfsplit[0]))
        continue
    else:
        logging.error("Found invalid subset: {} in the settings.conf file.\nThis is not in the acceptable list of subsets. Check your settings.conf\n Valid subsets are: {}".format(jamfsplit[0], ', '.join(validsubset)))
        raise SystemExit("Invalid Subset found in settings.conf")

### Setup Some Functions ###
snipe_api_count = 0
first_snipe_call = None
# This function is run every time a request is made, handles rate limiting for Snipe IT.
def request_handler(r, *args, **kwargs):
    global snipe_api_count
    global first_snipe_call
    if (snipe_base in r.url) and user_args.ratelimited:
        if '"messages":429' in r.text:
            logging.warn("Despite respecting the rate limit of Snipe, we've still been limited. Trying again after sleeping for 2 seconds.")
            time.sleep(2)
            re_req = r.request
            s = requests.Session()
            return s.send(re_req)
        if snipe_api_count == 0:
            first_snipe_call = time.time()
            time.sleep(0.5)
        snipe_api_count += 1
        time_elapsed = (time.time() - first_snipe_call)
        snipe_api_rate = snipe_api_count / time_elapsed
        if snipe_api_rate > 1.95:
            sleep_time = 0.5 + (snipe_api_rate - 1.95)
            logging.debug('Going over snipe rate limit of 120/minute ({}/minute), sleeping for {}'.format(snipe_api_rate,sleep_time))
            time.sleep(sleep_time)
        logging.debug("Made {} requests to Snipe IT in {} seconds, with a request being sent every {} seconds".format(snipe_api_count, time_elapsed, snipe_api_rate))
    if '"messages":429' in r.text:
        logging.error(r.content)
        raise SystemExit("We've been rate limited. Use option -r to respect the built in Snipe IT API rate limit of 120/minute.")
    return r

# Function to make the API call for all JAMF devices
def get_jamf_computers():
    api_url = '{0}/JSSResource/computers'.format(jamfpro_base)
    logging.debug('Calling for JAMF computers against: {}\n The username, passwords, and headers for this GET requestcan be found near the beginning of the output.'.format(api_url))
    response = requests.get(api_url, auth=(jamf_api_user, jamf_api_password), headers=jamfheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        return response.json()
    elif b'policies.ratelimit.QuotaViolation' in response.content:
        logging.info('JAMFPro responded with error code: {} - Policy Ratelimit Quota Violation - when we tried to get a list of computers Waiting a bit to retry the lookup.'.format(response))
        logging.warning('JAMFPro Ratelimit exceeded: pausing ')
        time.sleep(75)
        logging.info("Finished waiting. Retrying lookup...")
        newresponse = get_jamf_computers()
        return newresponse
    else:
        logging.warning('Received an invalid status code when trying to retreive JAMF Device list:{} - {}'.format(response.status_code, response.content))
        logging.debug("Returning a null value for the function.")
        return None

# Function to make the API call for all JAMF mobile devices
def get_jamf_mobiles():
    api_url = '{0}/JSSResource/mobiledevices'.format(jamfpro_base)
    logging.debug('Calling for JAMF mobiles against: {}\n The username, passwords, and headers for this GET requestcan be found near the beginning of the output.'.format(api_url))
    response = requests.get(api_url, auth=(jamf_api_user, jamf_api_password), headers=jamfheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        return response.json()
    elif b'policies.ratelimit.QuotaViolation' in response.content:
        logging.info('JAMFPro responded with error code: {} - Policy Ratelimit Quota Violation - when we tried to get a list of mobiles Waiting a bit to retry the lookup.'.format(response))
        logging.warning('JAMFPro Ratelimit exceeded: pausing ')
        time.sleep(75)
        logging.info("Finished waiting. Retrying lookup...")
        newresponse = get_jamf_mobiles()
        return newresponse
    else:
        logging.warning('Received an invalid status code when trying to retreive JAMF Device list:{} - {}'.format(response.status_code, response.content))
        logging.debug("Returning a null value for the function.")
        return None

# Function to lookup a JAMF asset by id.
def search_jamf_asset(jamf_id):
    api_url = "{}/JSSResource/computers/id/{}".format(jamfpro_base, jamf_id)
    response = requests.get(api_url, auth=(jamf_api_user, jamf_api_password), headers=jamfheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        jsonresponse = response.json()
        logging.debug("Returning: {}".format(jsonresponse['computer']))
        return jsonresponse['computer']
    elif b'policies.ratelimit.QuotaViolation' in response.content:
        logging.info('JAMFPro responded with error code: {} - Policy Ratelimit Quota Violation - when we tried to look up id: {} Waiting a bit to retry the lookup.'.format(response, jamf_id))
        logging.warning('JAMFPro Ratelimit exceeded: pausing ')
        time.sleep(75)
        logging.info("Finished waiting. Retrying lookup...")
        newresponse = search_jamf_asset(jamf_id)
        return newresponse
    else:
        logging.warning('JAMFPro responded with error code:{} when we tried to look up id: {}'.format(response, jamf_id))
        logging.debug("Returning a null value for the function.")
        return None

# Function to lookup a JAMF mobile asset by id.
def search_jamf_mobile(jamf_id):
    api_url = "{}/JSSResource/mobiledevices/id/{}".format(jamfpro_base, jamf_id)
    response = requests.get(api_url, auth=(jamf_api_user, jamf_api_password), headers=jamfheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        jsonresponse = response.json()
        logging.debug("Returning: {}".format(jsonresponse['mobile_device']))
        return jsonresponse['mobile_device']
    elif b'policies.ratelimit.QuotaViolation' in response.content:
        logging.info('JAMFPro responded with error code: {} - Policy Ratelimit Quota Violation - when we tried to look up id: {} Waiting a bit to retry the lookup.'.format(response, jamf_id))
        logging.warning('JAMFPro Ratelimit exceeded: pausing ')
        time.sleep(75)
        logging.info("Finished waiting. Retyring lookup...")
        newresponse = search_jamf_asset(jamf_id)
        return newresponse
    else:
        logging.warning('JAMFPro responded with error code:{} when we tried to look up id: {}'.format(response, jamf_id))
        logging.debug("Returning a null value for the function.")
        return None

# Function to lookup a snipe asset by serial number.
def search_snipe_asset(serial):
    api_url = '{}/api/v1/hardware/byserial/{}'.format(snipe_base, serial)
    response = requests.get(api_url, headers=snipeheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        # Check to make sure there's actually a result
        if jsonresponse['total'] == 1:
            return jsonresponse
        elif jsonresponse['total'] == 0:
            logging.info("No assets match {}".format(serial))
            return "NoMatch"
        else:
            logging.warning('FOUND {} matching assets while searching for: {}'.format(jsonresponse['total'], serial))
            return "MultiMatch"
    else:
        logging.warning('Snipe-IT responded with error code:{} when we tried to look up: {}'.format(response.text, serial))
        logging.debug('{} - {}'.format(response.status_code, response.content))
        return "ERROR"

# Function to get all item of a certain type (models/licenses)
def get_snipe_list(list_type):
    api_url = '{}/api/v1/{}'.format(snipe_base, list_type)
    logging.debug('Calling against: {}'.format(api_url))
    response = requests.get(api_url, headers=snipeheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        logging.info("Got a valid response that should have {} {}.".format(jsonresponse['total'], list_type))
        if jsonresponse['total'] <= len(jsonresponse['rows']) :
            return jsonresponse
        else:
            logging.info("We didn't get enough results so we need to get them again.")
            api_url = '{}/api/v1/{}?limit={}'.format(snipe_base, list_type, jsonresponse['total'])
            newresponse = requests.get(api_url, headers=snipeheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
            if newresponse.status_code == 200:
                newjsonresponse = newresponse.json()
                if newjsonresponse['total'] == len(newjsonresponse['rows']) :
                    return newjsonresponse
                else:
                    logging.error("We couldn't seem to get all of the {}".format(list_type))
                    raise SystemExit("Unable to get all {} objects from Snipe-IT instanace".format(list_type))
            else:
                logging.error('When we tried to retreive a list of {}, Snipe-IT responded with error status code:{} - {}'.format(list_type, response.status_code, response.content))
                raise SystemExit("Snipe models API endpoint failed.")
    else:
        logging.error('When we tried to retreive a list of {}, Snipe-IT responded with error status code:{} - {}'.format(list_type, response.status_code, response.content))
        raise SystemExit("Snipe {} API endpoint failed.".format(list_type))


# Recursive function returns all users in a Snipe Instance, 100 at a time.
def get_snipe_users(previous=[]):
    user_id_url = '{}/api/v1/users'.format(snipe_base)
    payload = {
        'limit': 100,
        'offset': len(previous)
    }
    logging.debug('The payload for the snipe users GET is {}'.format(payload))
    response = requests.get(user_id_url, headers=snipeheaders, json=payload, hooks={'response': request_handler})
    response_json = response.json()
    current = response_json['rows']
    if len(previous) != 0:
        current = previous + current
    if response_json['total'] > len(current):
        logging.debug('We have more than 100 users, get the next page - total: {} current: {}'.format(response_json['total'], len(current)))
        return get_snipe_users(current)
    else:
        return current

# Function to search snipe for a user
def get_snipe_user_id(name):
    if name == '' or not name:
        return False
    name = name.lower()
    is_username = ' ' not in name
    for user in snipeusers:
        if (is_username and user['username'].lower() == name) or (not is_username and user['name'].lower() == name):
            return user['id']
    return False


# Function that creates a new Snipe Model - not an asset - with a JSON payload
def create_snipe_model(payload):
    global modelnumbers
    api_url = '{}/api/v1/models'.format(snipe_base)
    logging.debug('Calling to create new snipe model type against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        modelnumbers[jsonresponse['payload']['model_number']] = jsonresponse['payload']['id']
        return True
    else:
        logging.warning('Error code: {} while trying to create a new model.'.format(response.status_code))
        return False

# Function to create a new asset by passing array
def create_snipe_asset(payload):
    api_url = '{}/api/v1/hardware'.format(snipe_base)
    logging.debug('Calling to create a new asset against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug(response.text)
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        return 'AssetCreated', response
    else:
        logging.error('Asset creation failed for asset {} with error {}'.format(payload['name'],response.text))
        return response

# Function that updates a snipe asset with a JSON payload
def update_snipe_asset(snipe_id, payload):
    api_url = '{}/api/v1/hardware/{}'.format(snipe_base, snipe_id)
    logging.debug('The payload for the snipe update is: {}'.format(payload))
    response = requests.patch(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    # Verify that the payload updated properly.
    goodupdate = True
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - Checking the payload updated properly: If you error here it's because you configure the API mapping right.")
        jsonresponse = response.json()
        for key in payload:
            if key == 'purchase_date':
                payload[key] = payload[key] + " 00:00:00"
            if payload[key] == '':
                payload[key] = None
            if jsonresponse['payload'][key] != payload[key]:
                logging.warning('Unable to update ID: {}. We failed to update the {} field with "{}"'.format(snipe_id, key, payload[key]))
                goodupdate = False
            else:
                logging.info("Sucessfully updated {} with: {}".format(key, payload[key]))
        return goodupdate
    else:
        logging.warning('Whoops. Got an error status code while updating ID {}: {} - {}'.format(snipe_id, response.status_code, response.content))
        return False

# Function that checks in an asset in snipe
def checkin_snipe_asset(asset_id):
    api_url = '{}/api/v1/hardware/{}/checkin'.format(snipe_base, asset_id)
    payload = {
        'note':'Checked in automatically.'
    }
    logging.debug('The payload for the snipe checkin is: {}'.format(payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug('The response from Snipe IT is: {}'.format(response.json()))
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        return "CheckedOut"
    else:
        return response

# Function that checks out an asset in snipe
def checkout_snipe_asset(user_id, asset_id, checked_out_user=None):
    logging.debug('Asset {} is being checked out to user id {}'.format(user_id, asset_id))
    if not user_id:
        logging.info('No user id was provided for device checkout')
        return "NotFound"
    if checked_out_user == None:
        logging.info("Not checked out, checking out to user id {}".format(user_id))
    elif checked_out_user == "NewAsset":
        logging.info("First time this asset will be checked out, checking out to user id {}".format(user_id))
    elif checked_out_user['id'] == user_id:
        logging.info("{} already checked out to user id {}".format(asset_id, user_id))
        return 'CheckedOut'
    else:
        logging.info("Checking in {} to check it out to user id {}".format(asset_id, user_id))
        checkin_snipe_asset(asset_id)
    api_url = '{}/api/v1/hardware/{}/checkout'.format(snipe_base, asset_id)
    logging.info("Checking out {} to check it out to user id {}".format(asset_id, user_id))
    payload = {
        'checkout_to_type': 'user',
        'assigned_user': user_id,
        'note': 'Checked out automatically'
    }
    logging.debug('The payload for the snipe checkin is: {}'.format(payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug('The response from Snipe IT is: {}'.format(response.json()))
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        return "CheckedOut"
    else:
        logging.error('Asset checkout failed for asset {} with error {}'.format(asset_id, response.text))
        return response

# Function to strip punctuation from a string
def strip_punct(s):
    return s.translate(str.maketrans('', '', string.punctuation))

# Function to create a manufacturer in Snipe
def create_snipe_manufacturer(name):
    global snipemanufacturers
    api_url = '{}/api/v1/manufacturers'.format(snipe_base)
    payload = {
        'name': name
    }
    logging.debug('Calling to create new snipe license type against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.info("Created manufacturer '{}'.".format(name)) 
        jsonresponse = response.json()
        if 'payload' in jsonresponse and 'id' in jsonresponse['payload']:
            snipemanufacturers['rows'].append(jsonresponse['payload'])
            return jsonresponse['payload']['id']
        else:
            return False
    else:
        logging.warning('Error code: {} while trying to create a new manufacturer.'.format(response.status_code))
        return False

# Function to get a manufacturer id in Snipe
def get_snipe_manufacturer_id(name):
    for manufacturer in snipemanufacturers['rows']:
        if manufacturer['name'].lower() == name.lower():
            return manufacturer['id']
    return False

# Function to create a software license in Snipe
def create_snipe_license(payload, user_id=0):
    global snipelicenses
    if not 'seats' in payload:
        payload['seats'] = 1
    api_url = '{}/api/v1/licenses'.format(snipe_base)
    logging.debug('Calling to create new snipe license type against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        logging.info("Created license for '{}'.".format(payload['name'])) 
        snipelicenses['rows'].append(jsonresponse['payload'])
        snipeseats[jsonresponse['payload']['id']] = get_snipe_license_seats(jsonresponse['payload']['id'])
        if user_id > 0:
            checkout_snipe_license_seat(jsonresponse['payload']['id'], 1, user_id)
        return jsonresponse['payload']['id']
    else:
        logging.warning('Error code: {} while trying to create a new license.'.format(response.status_code))
        return False

# Function to get a software license id from Snipe
def get_snipe_license_id(name, user_id=False):
    for license in snipelicenses['rows']:
        if license['name'].lower() == name.lower():
            if not user_id and snipeseats[license['id']]['total'] > 1:
                return license['id']
            elif license['id'] in snipeseats:
                for seat in snipeseats[license['id']]['rows']:
                    if (not user_id and seat['assigned_user'] is None) or (user_id and seat['assigned_user'] is not None and seat['assigned_user']['id'] == user_id):
                        return license['id'], seat['id']
    return False

# Function to update available seats for a license
def update_snipe_license_seats(id, seats):
    global snipeseats
    payload = {'seats': seats}
    api_url = '{}/api/v1/licenses/{}'.format(snipe_base, id)
    response = requests.put(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        snipeseats[id] = get_snipe_license_seats(id)
        return True
    else:
        logging.warning('Error code: {} while trying to update license.'.format(response.status_code))
        return False

# Function to update a snipe license
def update_snipe_license(id, payload):
    api_url = '{}/api/v1/licenses/{}'.format(snipe_base, id)
    response = requests.put(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        return True
    else:
        logging.warning('Error code: {} while trying to update license.'.format(response.status_code))
        return False

# Function to get seats for a license
def get_snipe_license_seats(id):

    api_url = '{}/api/v1/licenses/{}/seats'.format(snipe_base, id)
    response = requests.get(api_url, headers=snipeheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()

        logging.info("Got a valid response that should have {}.".format(jsonresponse['total']))
        if jsonresponse['total'] <= len(jsonresponse['rows']) :
            return jsonresponse
        else:
            logging.info("We didn't get enough results so we need to get them again.")
            api_url = '{}/api/v1/licenses/{}/seats?limit={}'.format(snipe_base, id, jsonresponse['total'])
            newresponse = requests.get(api_url, headers=snipeheaders, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
            if newresponse.status_code == 200:
                newjsonresponse = newresponse.json()
                if newjsonresponse['total'] == len(newjsonresponse['rows']) :
                    return newjsonresponse
                else:
                    logging.error("We couldn't seem to get all of the seats for the license")
                    raise SystemExit("Unable to get all seat objects from Snipe-IT instanace")
            else:
                logging.error('When we tried to retreive a list of license seats, Snipe-IT responded with error status code:{} - {}'.format(response.status_code, response.content))
                raise SystemExit("Snipe models API endpoint failed.")
    else:
        logging.error('When we tried to retreive a list of license seats, Snipe-IT responded with error status code:{} - {}'.format(response.status_code, response.content))
        raise SystemExit("Snipe license seats API endpoint failed.")

# Function to get seats for all licenses
def get_snipe_seats(licenses):
    seats = {}
    for license in licenses['rows']:
        seats[license['id']] = get_snipe_license_seats(license['id'])
    return seats

# Function to get seat id for a license based on license id and user id
def get_snipe_license_seat_id(id, user_id=0, asset_id=0):
    if id in snipeseats:
        for seat in snipeseats[id]['rows']:
            if (seat['assigned_user'] is not None and seat['assigned_user']['id'] == user_id) or (seat['assigned_asset'] is not None and seat['assigned_user']['id'] == asset_id):
                return seat['id']
    return False

# Function to get next free license seat id
def get_snipe_next_free_license_seat_id(id):
    seat_id = False
    if id in snipeseats:
        for seat in list(reversed(snipeseats[id]['rows'])):
            if seat['assigned_user'] is None and seat['assigned_asset'] is None:
                return seat['id']
    return False

# Function to check out a Snipe license
def checkout_snipe_license_seat(id, seat_id, user_id=0, asset_id=0):
    global snipeseats
    payload = {
        'note':'Checked out automatically.'
    }
    if user_id > 0:
        payload['assigned_to'] = user_id
    if asset_id > 0:
        payload['asset_id'] = asset_id
    api_url = '{}/api/v1/licenses/{}/seats/{}'.format(snipe_base, id, seat_id)
    logging.debug('Calling to checkout license against: {}\nThe payload for the PUT request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.put(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug(response.text)
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        logging.info('Software license checked out')
        snipeseats[id] = get_snipe_license_seats(id)
        return True
    else:
        logging.error('License checkout failed with error {}'.format(response.text))
        return False

# Function to check in a Snipe license
def checkin_snipe_license_seat(id, seat_id):
    global snipeseats
    api_url = '{}/api/v1/licenses/{}/seats/{}'.format(snipe_base, id, seat_id)
    payload = {
        'assigned_to': None,
        'asset_id': None,
        'note':'Checked in automatically.'
    }
    logging.debug('Calling to checkout license against: {}\nThe payload for the PUT request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.put(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug(response.text)
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        logging.info('Software license checked in')
        snipeseats[id] = get_snipe_license_seats(id)
        return True
    else:
        logging.error('License seat checkin failed with error {}'.format(response.text))
        return False

# Function to retrieve all (active) users from Okta
def get_okta_users(previous=[], limit=200):
    after = ''
    if len(previous) != 0:
        after = '&after={}'.format(previous[-1]['id'])
    url = "{}/api/v1/users?filter=status%20eq%20%22ACTIVE%22{}&limit={}".format(okta_base, after, limit)
    response = requests.get(url, headers=oktaheaders, hooks={'response': request_handler})
    if response.status_code == 200:
        current = response.json()
        count = len(current)
        logging.info("Count is {}".format(count))
        if len(previous) != 0:
            current = previous + current
        if count == limit and len(current) < 1000:
            logging.debug("Additional Okta request will be initiated (more than {} users)".format(limit))
            return get_okta_users(current, limit)
        else:
            return current
    else:
        logging.error('Okta user list request failed with error {}'.format(response.text))
        return previous

# Function to create a Snipe user
def create_snipe_user(payload):
    global snipeusers
    api_url = '{}/api/v1/users'.format(snipe_base)
    logging.debug('Calling to create a new user against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = requests.post(api_url, headers=snipeheaders, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug(response.text)
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        jsonresponse = response.json()
        if 'payload' in jsonresponse and jsonresponse['payload'] is not None:
            user_obj = {'id': jsonresponse['payload']['id'], 'username': jsonresponse['payload']['username'], 'name': jsonresponse['payload']['name'], 'last_updated': 0}
            snipeusers.append(user_obj)
            return True
        else:
            logging.error('Missing payload')
            return False
    else:
        logging.error('User creation failed for {} with error {}'.format(payload['username'],response.text))
        return False


### Run Testing ###
# Report if we're verifying SSL or not.
logging.info("SSL Verification is set to: {}".format(user_args.do_not_verify_ssl))

# Do some tests to see if the hosts are up.
logging.info("Running tests to see if hosts are up.")
try:
    SNIPE_UP = True if requests.get(snipe_base, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler}).status_code == 200 else False
except Exception as e:
    logging.exception(e)
    SNIPE_UP = False
try:
    JAMF_UP = True if requests.get(jamfpro_base, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler}).status_code in (200, 401) else False
except Exception as e:
    logging.exception(e)
    JAMF_UP = False

if SNIPE_UP is False:
    logging.error('Snipe-IT looks like it is down from here. \nPlease check your config in the settings.conf file, or your instance.')
else:
    logging.info('We were able to get a good response from your Snipe-IT instance.')
if JAMF_UP is False:
    logging.error('JAMFPro looks down from here. \nPlease check the your config in the settings.conf file, or your hosted JAMFPro instance.')
else:
    logging.info('We were able to get a good response from your JAMFPro instance.')

# Exit if you can't contact SNIPE
if ( JAMF_UP == False ) or ( SNIPE_UP == False ):
    raise SystemExit("Error: Host could not be contacted.")

# Test that we can actually connect with the API keys.
##TODO Write some more tests here. ha!

logging.info("Finished running our tests.")


### Get Started ###

# Get a list of known models, licenses and manufacturers from Snipe
logging.info("Getting a list of manufacturers, models and licenses that Snipe knows about.")
snipemodels = get_snipe_list('models')
snipelicenses = get_snipe_list('licenses')
snipeseats = get_snipe_seats(snipelicenses)
snipemanufacturers = get_snipe_list('manufacturers')

# Build array of known usernames
snipeusers = get_snipe_users()
tmp_users = []
for user in snipeusers:
    user_obj = {'id': user['id'], 'username': user['username'], 'name': user['name'], 'last_updated': 0}
    if 'updated_at' in user and user['updated_at'] is not None:
        user_obj['last_updated'] = user['updated_at']['datetime']
    tmp_users.append(user_obj)
snipeusers = tmp_users

# Get Okta users
okta_users = get_okta_users()
for okta_user in okta_users:
    if not get_snipe_user_id(okta_user['profile']['login']) and 'department' in okta_user['profile'] and okta_user['profile']['department'] is not None and okta_filter in okta_user['profile']['department'].lower() and '.team' not in okta_user['profile']['email']:
        logging.info('User {} does not exist in Snipe, creating...'.format(okta_user['profile']['login']))
        # Even though login will be disabled for the user, we have to set a password (otherwise the user will not be created)
        pw = '0@8OD3+3Q>eDD^Y'
        payload = {'first_name': okta_user['profile']['firstName'], 'last_name': okta_user['profile']['lastName'], 'username': okta_user['profile']['login'], 'password': pw, 'password_confirmation': pw}
        if 'title' in okta_user['profile'] and okta_user['profile']['title'] is not None:
            payload['jobtitle'] = okta_user['profile']['title']
        create_snipe_user(payload)
okta_users = None

# Get custom field column names
fields = {}
snipefields = get_snipe_list('fields')
for field in snipefields['rows']:
    if field['name'].lower() == 'mac address' or field['name'].lower() == 'mac':
        fields['mac'] = field['db_column_name']
    elif field['name'].lower() == 'cpu' or field['name'].lower() == 'processor':
        fields['cpu'] = field['db_column_name']
    elif 'imei' in field['name'].lower():
        fields['imei'] = field['db_column_name']
    elif 'year' in field['name'].lower():
        fields['year'] = field['db_column_name']
    elif 'ram' in field['name'].lower() or field['name'].lower() == 'memory':
        fields['ram'] = field['db_column_name']
    elif field['name'].lower() == 'filevault enabled':
        fields['filevault_enabled'] = field['db_column_name']
    elif field['name'].lower() == 'os' or field['name'].lower() == 'operating system':
        fields['os'] = field['db_column_name']
    elif field['name'].lower() == 'storage' or field['name'].lower() == 'hd':
        fields['storage'] = field['db_column_name']


logging.debug("Parsing the {} model results for models with model numbers.".format(len(snipemodels['rows'])))
modelnumbers = {}
peripherals = {}
for model in snipemodels['rows']:
    if model['model_number'] == "":
        logging.debug("The model, {}, did not have a model number. Skipping.".format(model['name']))
        continue
    elif model['category']['id'] == config['snipe-it']['peripheral_category_id']:
        peripherals[model['id']] = model['name']
    modelnumbers[model['model_number']] = model['id']
logging.info("Our list of models has {} entries.".format(len(modelnumbers)))
logging.debug("Here's the list of the {} models and their id's that we were able to collect:\n{}".format(len(modelnumbers), modelnumbers))

# Get JAMF the IDS of all active assets.
jamf_computer_list = get_jamf_computers()
# jamf_mobile_list = get_jamf_mobiles()
jamf_types = {
    'computers': jamf_computer_list,
    # We are not going to be using JAMF's mobile devices....
    # 'mobile_devices': jamf_mobile_list
}

logging.info('Done with third party API Calls')

# Get Google assets.
google_device_list = []

TotalNumber = 0
if user_args.computers:
    TotalNumber = len(jamf_types['computers']['computers'])
elif user_args.mobiles:
    TotalNumber = len(jamf_types['mobile_devices']['mobile_devices'])
else:
    for jamf_type in jamf_types:
        TotalNumber += len(jamf_types[jamf_type][jamf_type])

if user_args.mobiles:
    TotalNumber += len(google_device_list)

# Make sure we have a good list.
if jamf_computer_list is not None:
    logging.info('Received a list of JAMF assets that had {} entries.'.format(TotalNumber))
else:
    logging.error("We were not able to retreive a list of assets from your JAMF instance. It's likely that your settings, or credentials are incorrect. Check your settings.conf and verify you can make API calls outside of this system with the credentials found in your settings.conf")
    # raise SystemExit("Unable to get JAMF Computers.")
    jamf_types = []

# After this point we start editing data, so quit if this is a dryrun
if user_args.dryrun:
    raise SystemExit("Dryrun: Complete.")

# From this point on, we're editing data.
logging.info('Starting to Update Inventory')

# this is where we would parse Google devices
# CurrentNumber = 0
# GET https://admin.googleapis.com/admin/directory/v1/customer/{customerId}/devices/mobile (list)
# "mobiledevices" array with object
# "manufacturer", "model", "os", "networkOperator", "deviceId", "imei", "wifiMacAddress"

CurrentNumber = 0

for jamf_type in jamf_types:
    if user_args.computers:
        if jamf_type != 'computers':
            continue
    if user_args.mobiles:
        if jamf_type != 'mobile_devices':
            continue

    for jamf_asset in jamf_types[jamf_type][jamf_type]:

        CurrentNumber += 1

        logging.info("Processing entry {} out of {} - JAMFID: {} - NAME: {}".format(CurrentNumber, TotalNumber, jamf_asset['id'], jamf_asset['name']))
        
        # Search through the list by ID for all asset information\
        if jamf_type == 'computers':
            jamf = search_jamf_asset(jamf_asset['id'])
        elif jamf_type == 'mobile_devices':
            jamf = search_jamf_mobile(jamf_asset['id'])

        if jamf is None:
            continue

        # Check that the manufacturer exists, if not create it.
        make = jamf['hardware']['make']
        if make == '':
            make = 'Apple'
        man_id = get_snipe_manufacturer_id(make)
        if not man_id:
            man_id = create_snipe_manufacturer(make)

        # Who is the device checked out to?
        username = False
        user_id = False
        user = 'Unknown'

        # What is the name of the person?
        if 'location' in jamf and 'username' in jamf['location'] and jamf['location']['username'] is not None and jamf['location']['username'] != '':
            username = jamf['location']['username']
            if '@' not in username:
                username = '{}@{}'.format(username, emailDomain)
            user_id = get_snipe_user_id(username)
            user = jamf['location']['real_name']
            if user == '':
                user == jamf['location']['realname']
                if user == '':
                    user = 'Unknown'
        elif 'groups_accounts' in jamf and 'local_accounts' in jamf['groups_accounts'] and jamf['groups_accounts']['local_accounts'] is not None:
            for user_account in jamf['groups_accounts']['local_accounts']:
                if ' ' in user_account['realname']:
                    user = user_account['realname']
                    user_id = get_snipe_user_id(user)
                    if user_id:
                        break

        # Do we have a manufacturer id so that we can proceed?
        if man_id:

            # Check that the model number exists in snipe, if not create it.
            if jamf_type == 'computers':
                if jamf['hardware']['model_identifier'] not in modelnumbers:
                    logging.info("Could not find a model ID in snipe for: {}".format(jamf['hardware']['model_identifier']))
                    newmodel = {"category_id": config['snipe-it']['computer_model_category_id'], "manufacturer_id": man_id, "name": jamf['hardware']['model'], "model_number": jamf['hardware']['model_identifier']}
                    if 'computer_custom_fieldset_id' in config['snipe-it']:
                        fieldset_split = config['snipe-it']['computer_custom_fieldset_id']
                        newmodel['fieldset_id'] = fieldset_split
                    create_snipe_model(newmodel)
            elif jamf_type == 'mobile_devices':
                if jamf['general']['model_identifier'] not in modelnumbers:
                    logging.info("Could not find a model ID in snipe for: {}".format(jamf['general']['model_identifier']))
                    newmodel = {"category_id": config['snipe-it']['mobile_model_category_id'], "manufacturer_id": man_id,"name": jamf['general']['model'], "model_number": jamf['general']['model_identifier']}
                    if 'mobile_custom_fieldset_id' in config['snipe-it']:
                        fieldset_split = config['snipe-it']['mobile_custom_fieldset_id']
                        newmodel['fieldset_id'] = fieldset_split
                    create_snipe_model(newmodel)

            # Pass the SN from JAMF to search for a match in Snipe
            snipe = search_snipe_asset(jamf['general']['serial_number'])

            # Create a new asset if there's no match:
            if snipe == 'NoMatch':

                logging.info("Creating a new asset in snipe for JAMF ID {} - {}".format(jamf['general']['id'], jamf['general']['name']))
                # This section checks to see if the asset tag was already put into JAMF, if not it creates one with with Jamf's ID.
                t = '{}'.format(jamf['general']['id'])
                if jamf_type == 'mobile_devices':
                    jamf_asset_tag = 'jamfid-m-{}'.format(t.zfill(3))
                else:
                    jamf_asset_tag = 'jamfid-{}'.format(t.zfill(3))

                # Create the payload
                if jamf_type == 'mobile_devices':
                    logging.debug("Payload is being made for a mobile device")
                    newasset = {'asset_tag': jamf_asset_tag, 'model_id': modelnumbers['{}'.format(jamf['general']['model_identifier'])], 'name': strip_punct(jamf['general']['name']), 'status_id': defaultStatus, 'serial': jamf['general']['serial_number']}
                    # add custom field data...
                    if 'mobile_custom_fieldset_id' in config['snipe-it']:
                        if 'mac' in fields:
                            newasset[fields['mac']] = jamf['general']['mac_address']
                        if 'imei' in fields:
                            newasset[fields['imei']] = jamf['general']['mac_address']
                        if 'os' in fields:
                            newasset[fields['os']] = '{} {}'.format(jamf['hardware']['os_name'], jamf['hardware']['os_version'])
                elif jamf_type == 'computers':
                    logging.debug("Payload is being made for a computer")
                    newasset = {'asset_tag': jamf_asset_tag, 'model_id': modelnumbers['{}'.format(jamf['hardware']['model_identifier'])], 'name': strip_punct(jamf['general']['name']), 'status_id': defaultStatus, 'serial': jamf['general']['serial_number'], 'notes': 'Assigned to {}.'.format(user)}
                    # add custom field data...
                    if 'computer_custom_fieldset_id' in config['snipe-it']:
                        if 'mac' in fields:
                            newasset[fields['mac']] = jamf['general']['mac_address']
                        if 'cpu' in fields:
                            newasset[fields['cpu']] = jamf['hardware']['processor_type']
                        if 'year' in fields:
                            match = re.search('\d{4}', jamf['hardware']['model'])
                            if match:
                                newasset[fields['year']] = int(match.group(0))
                        if 'ram' in fields:
                            newasset[fields['ram']] = '{} GB'.format(math.floor(int(jamf['hardware']['total_ram_mb']) / 1000))
                        if 'os' in fields:
                            newasset[fields['os']] = '{} {}'.format(jamf['hardware']['os_name'], jamf['hardware']['os_version'])
                        if 'storage' in fields and 'storage' in jamf['hardware'] and len(jamf['hardware']['storage']) > 0:
                            size = 25 * round(math.floor(int(jamf['hardware']['storage'][0]['size']) / 1000) / 25)
                            unit = "GB"
                            if size >= 1000:
                                size = size / 1000
                                unit = "TB"
                            newasset[fields['storage']] = '{} {}'.format(size, unit)

                if jamf['general']['serial_number'] == 'Not Available':
                    logging.warning("The serial number is not available in JAMF. This is normal for DEP enrolled devices that have not yet checked in for the first time. Since there's no serial number yet, we'll skip it for now.")
                    continue
                else:
                    new_snipe_asset = create_snipe_asset(newasset)
                    if new_snipe_asset[0] != "AssetCreated":
                        continue
                    if user_id and (user_args.users or user_args.users_force or user_args.users_inverse):
                        logging.info('Checking out new item {} to user id {}'.format(jamf['general']['name'], user_id))
                        checkout_snipe_asset(user_id, new_snipe_asset[1].json()['payload']['id'], "NewAsset")

            # Log an error if there's an issue, or more than once match.
            elif snipe == 'MultiMatch':
                logging.warning("WARN: You need to resolve multiple assets with the same serial number in your inventory. If you can't find them in your inventory, you might need to purge your deleted records. You can find that in the Snipe Admin settings. Skipping serial number {} for now.".format(jamf['general']['serial_number']))
            elif snipe == 'ERROR':
                logging.error("We got an error when looking up serial number {} in snipe, which shouldn't happen at this point. Check your snipe instance and setup. Skipping for now.".format(jamf['general']['serial_number']))
            else:
                # Only update if JAMF has more recent info.
                snipe_id = snipe['rows'][0]['id']
                snipe_time = snipe['rows'][0]['updated_at']['datetime']
                if jamf_type == 'computers':
                    jamf_time = jamf['general']['report_date']
                elif jamf_type == 'mobile_devices':
                    jamf_time = jamf['general']['last_inventory_update']
                    
                # Check to see that the JAMF record is newer than the previous Snipe update, or if it is a new record in Snipe
                if ( jamf_time > snipe_time ) or ( user_args.force ):
                    if user_args.force:
                        logging.debug("Forced the Update regardless of the timestamps below.")
                    logging.debug("Updating the Snipe asset because JAMF has a more recent timestamp: {} > {} or the Snipe Record is new.".format(jamf_time, snipe_time))
                    for snipekey in config['{}-api-mapping'.format(jamf_type)]:
                        jamfsplit = config['{}-api-mapping'.format(jamf_type)][snipekey].split()
                        for i, item in enumerate(jamfsplit):
                            try:
                                item = int(item)
                            except ValueError:
                                logging.debug('{} is not an integer.'.format(item))
                            if i == 0:
                                jamf_value = jamf[item]
                            else:
                                if jamfsplit[0] == 'extension_attributes':
                                    for attribute in jamf_value:
                                        if attribute['id'] == item:
                                            jamf_value = attribute['value']
                                else:
                                    jamf_value = jamf_value[item]
                        payload = {
                            snipekey: jamf_value
                        }
                        latestvalue = jamf_value

                        # Need to check that we're not needlessly updating the asset.
                        # If it's a custom value it'll fail the first section and send it to except section that will parse custom sections.
                        try:
                            if snipe['rows'][0][snipekey] != latestvalue:
                                update_snipe_asset(snipe_id, payload)
                            else:
                                logging.debug("Skipping the payload, because it already exits.")
                        except:
                            logging.debug("The snipekey lookup failed (custom field). Parsing those to see if it needs to be updated or not.")
                            needsupdate = False
                            for CustomField in snipe['rows'][0]['custom_fields']:
                                if snipe['rows'][0]['custom_fields'][CustomField]['field'] == snipekey :
                                    if snipe['rows'][0]['custom_fields'][CustomField]['value'] != latestvalue:
                                        logging.debug("Found the field, and the value needs to be updated from {} to {}".format(snipe['rows'][0]['custom_fields'][CustomField]['value'], latestvalue))
                                        needsupdate = True
                            if needsupdate is True:
                                update_snipe_asset(snipe_id, payload)
                            else:
                                logging.debug("Skipping the payload because it already exists, or the Snipe key we're mapping to doesn't.")

                    # Device checkout
                    if user_id and (((user_args.users or user_args.users_inverse) and snipe['rows'][0]['assigned_to'] == None) or user_args.force):

                        if snipe['rows'][0]['status_label']['status_meta'] in ('deployable', 'deployed'):
                            checkout_snipe_asset(user_id, snipe_id, snipe['rows'][0]['assigned_to'])
                        else:
                            logging.info("Can't checkout {} since the status isn't set to deployable.".format(jamf['general']['name']))

                else:
                    logging.info("Snipe Record is newer than the JAMF record, nothing to sync. If this wrong, then force an inventory update in JAMF.")
                    logging.debug("Not updating the Snipe asset because Snipe has a more recent timestamp: {} < {}".format(jamf_time, snipe_time))

                # Software
                """ if jamf_type == 'computers' and 'software' in jamf:
                    logging.debug("Checking for licensed software.")

                    packages = []

                    # Loop through the various software categories from JAMF output
                    for pkg in jamf['software']['licensed_software']:
                        if 'name' in pkg and '.app' in pkg['name']:   
                            pkg_name = pkg['name'].replace('.app', '')
                            pkg_name = pkg_name.lower()
                            if pkg_name not in packages:
                                packages.append(pkg_name)
                    for pkg in jamf['software']['installed_by_casper']:
                        if 'name' in pkg and '.app' in pkg['name']:
                            pkg_name = pkg['name'].replace('.app', '')
                            pkg_name = pkg_name.lower()
                            if pkg_name not in packages:
                                packages.append(pkg_name)
                    for pkg in jamf['software']['applications']:
                        if 'name' in pkg and '.app' in pkg['name']:
                            pkg_name = pkg['name'].replace('.app', '')
                            pkg_name = pkg_name.lower()
                            if pkg_name not in packages:
                                packages.append(pkg_name)

                    # Loop through known licensed packages and cross-reference...
                    for pkg_group in licensed_packages:
                        license_man_id = get_snipe_manufacturer_id(pkg_group['vendor'])
                        # Create vendor if it doesn't exist
                        if not license_man_id:
                            license_man_id = create_snipe_manufacturer(pkg_group['vendor'])
                        if license_man_id and user_id and user != 'Unknown':
                            for pkg in pkg_group['packages']:
                                license_details = get_snipe_license_id(pkg, user_id)
                                if pkg.lower() in packages:
                                    if not license_details:
                                        # See if there is a free license seat
                                        license_details = get_snipe_license_id(pkg)
                                        if not license_details: # There isn't a free license seat, create a new license
                                            payload = {'name': pkg, 'category_id': config['snipe-it']['software_category_id'], 'manufacturer_id': license_man_id, 'seats': 1, 'serial': 'Replace with key assigned to {}'.format(user)}
                                            create_snipe_license(payload, user_id)
                                        else: # There is a free license seat, check it out
                                            checkout_snipe_license_seat(license_details[0], license_details[1], user_id)
                                elif license_details: # Software is no longer installed, check the license seat back in
                                    checkin_snipe_license_seat(license_details[0], license_details[1])
                                    update_snipe_license(license_details[0], {'notes': 'Last checked out to {}.'.format(user), 'serial': ''}) """

logging.debug('Total amount of API calls made: {}.'.format(snipe_api_count))